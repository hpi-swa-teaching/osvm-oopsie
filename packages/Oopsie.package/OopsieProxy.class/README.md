I am a transparent proxy to an object from a simulated VM that is identified by the VM's ObjectMemory and the object's OOP in it. When I receive a message, I assume that the relevant code for answering the message is the same in both the host image and the simulated image*. I forward any message to the simulated object by evaluating it in the host image but redirecting all state accesses (variable reads/writes, primitive calls) to the object memory of the simulated VM. To this end, I use an OopsieProxySimulator, but my authors are considering to move to a more efficient implementation via bytecode rewriting (MethodMassage?) in the future. I implement the membrane pattern, i.e., the result of any message is wrapped into another proxy so the illusion of a single blended object space is held up. For performance reasons, certain primitive values such as Booleans or SmallIntegers are not wrapped into proxies by default, but can still be wrapped explicitly (see my class side's instance creation protocol).

I was originally designed to support bootstrapping of Scorch, an in-image adaptive optimizer for the Sista VM, by making it possible to run the optimizer NEXT to a simulator in the host VMMaker image and allowing it to interact with CompiledMethods and Contexts through proxies. In this way, Scorch and Sista can be developed in the simulator environment with all advantages over the production VM such as interactive debugging and runtime changes.
However, I am in no way restricted to CompiledMethods and Contexts, so I can also be applied to use the host image's tools such as inspectors and debuggers to access simulated objects during debugging.
	E.g., try this in the simulator:
		World firstSubmorph tryPrimitive: 114 withArgs: #()!
	And then in the debugger, do this:
		self inspectOop: self stackTop.

For more information, see: https://github.com/hpi-swa-teaching/osvm-oopsie
OOPSIE (Object-Oriented PointerS Interaction Engine) was originally developed for the OpenSmalltalk VMMaker simulator by Marius DÃ¶rbandt and Christoph Thiede and Eliot Miranda.

* This assumption is optional but allows us to not depend on or interfer with the interpreter of the simulated VM. Thus we stay more decoupled from the VM's interna and can work more reliably in post-mortem debugging scenarios. Another transparent proxy that actually executes message sends in the simulated image and allows bidirectional communication is available in the Yaros package.